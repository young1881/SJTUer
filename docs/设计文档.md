# 设计文档

## 项目架构

本项目为网页应用，采取前后端分离，docker整合部署的开发形式。

前端使用Vue框架进行组件式开发，使用插件Echarts进行数据动态可视化展示功能，使用Eslint进行代码格式化操作。

后端使用django框架进行应用式开发，在model层使用ORM模型执行对数据库sqlite的操作，在view层应用aliyun工具实现AI功能。使用Navicat与django.admin对数据库中的内容进行可视化查看与管理。

前后端交互使用基于promise请求的axios，传输内容使用Json编码。

![](./img/workflow.png)

## 环境依赖


|  名称  |  版本  |
| :-------: | :-------: |
| Python |  3.10  |
| Django |  4.0.2  |
|   Vue   |  3.3.4  |
| Node.js | 18.16.0 |
|   Npm   |  9.5.1  |

## git版本管理

### 代码管理

Git作为是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git支持版本库本地化，支持离线提交，相对独立不影响协同开发；同时支持快速切换分支方便合并，比较合并性能好。故而我们组使用Git管理代码。

### 分支管理

本项目的主分支为master分支，其余各分支以组员的名字命名。各位组员开发完一定的功能之后，先上传到自己的远程仓库分支进行备份；如果该功能已基本完成，或者其他成员的功能需要基于该功能进行开发，则将自己的分支merge到master分支。各位成员将从master分支拉取最新的代码。因此，master分支是用于汇总完善功能的分支，而自己的分支则主要起备份作用。

![](https://notes.sjtu.edu.cn/uploads/upload_d8654b1da5d41b3cfa74fe9ee55f8321.png)

## 前端组件设计

### 侧边栏

侧边栏负责内容组件的切换，同时能够在游客模式和用户模式显示不同内容，实现了网页的权限管理。初次进入界面右上角logo下会出现下划线提示，鼠标移动到页面右上角的图标能够自动触发侧边栏导航，并且下划线提示不会再显示，在移出之后侧边栏会自动隐藏，简洁大方。

### 搜索框组件

搜索框提供各种常用搜索引擎和网站的搜索服务，包括*百度、谷歌、必应、搜狗、360、知乎、有道、CSDN、Github、bilibili*等10种。搜索栏由左侧引擎图标、中间的输入框和右侧的执行按钮组成。用户将鼠标悬浮在搜索引擎图标上，下方就会显示切换面板，可从上述10种应用中选择。用户在输入框输入搜索内容后，按右侧按钮或键盘上的回车键均可弹出搜索结果页面。

### 常用网站组件

常用网站组件默认提供交大常用网址索引，如教务处、教学信息服务网、canvas、邮箱等，也提供大众常用网站，如百度、知乎、b站等。在登录模式下，用户可以对网站进行增加、删除、修改操作，定制个性化常用网站。点击常用网站最后的加号按钮，可以新增网站；在已有网站上右键点击，会弹出修改删除的操作框，供用户进行修改收藏名称或删除该常用网站。

### 资讯组件

资讯组件分为三个板块，分别是*教务信息，交大新闻和校外热门网站* ，其中，校外热门网站可以由用户点击进行切换。每个板块下方将会显示最新的新闻资讯，点击标题能够直接跳转到新闻的源网站。

### todolist组件

todolist组件是一个便捷的时间管理工具。在**添加**todo事件时，用户可以为每一个todo事件设置优先级、类别和预计消耗时间的属性，在添加完成之后，能够根据todo的完成与否和属性进行快速**筛选**，使得用户可以很容易找到适合当前做的事情。并且，用户可以随时**修改**todo事件的完成状态，也可以对todo事件进行**删除**操作。每个用户都有自己的todolist数据库，增删查改都会进行**数据库的同步**，使得用户在登录之后所有的数据状态都和上一次登录一样。

### 简洁模式

简洁模式为用户隐藏了其他功能，只保留时钟、搜索框和todo的小组件。其中，todo的小组件会在用户todolist中未完成的事件选取**优先级最高**的一个事件展示出来，用户也可以将该事件状态改为已完成（这个操作同样是与数据库同步的），则todo小组件将会显示下一个事件，直到所有事件都完成后，显示”congratus,you've finished all the tasks"的字样。

### 诗歌组件

诗歌组件显示在页面的最下方，在每一次刷新页面时会随机展示诗歌，为整个页面增添人文气息。

### 人流量组件

人流量组件会实时显示交大各图书馆和各个食堂的人流量数据，包括当前已有人数和总共的可容纳人数。人流量组件借助Echarts工具实现美观的可视化效果，整体数据以柱状数据图显示，当用户鼠标悬浮在某个数据的柱体上面则会显示更加详尽的数据，清晰直观。每张柱状图边上有侧边栏，可以实现可以实现看数据表，bar和stack相互转换,下载图片的功能。

### 壁纸切换和AI文生图组件

壁纸组件提供三种切换壁纸的方式：预设炫彩壁纸、上传本地图片和AI创作壁纸。其中，预设壁纸提供了五种精心设计的、主题鲜明的渐变色壁纸，具有简洁明快、清新优雅的效果；上传本地图片部分提供文件接口，用户可自主选择图片上传并设为壁纸；AI创作壁纸部分，用户可随心所欲输入中英文提示词或句子，并选择是否需要高清图片，[后端](#ai文字生成图片组件)通过阿里云图像生产技术生成符合要求的图片并设为壁纸，免去了用户想要某一主题的壁纸但苦于在互联网海量图片中搜索的烦恼，并且可按照用户的心情随变随换，提供个性化、即时化、轻便化的服务。

### 天气组件

天气组件主要调用了和风天气的桌面端网站天气插件。该组件具有快速集成、样式丰富的优点，包括当前天气实况、三日天气预报、空气质量、气象灾害预警、降雨预报等，并且能够自动确定用户当前城市，支持切换全国任意城市，背景会随着当前天气状况和昼夜时间而变化。

### 前端信息获取（Axios）

由于本项目是前后端分离的项目，因此前端与后端通信必不可少。

前端通过Axios库的函数发起POST请求到后端的某个路径，后端Django进行路由之后，选择对应的函数进行处理，最后返回一个JSON格式的响应，前端接收响应之后执行`.then`子句中的内容。

值得一提的是，前端需要传递给后端的数据，通过POST请求进行传递，具体而言就是存储在params这个变量中。

```js
const siteName = this.addName;
this.siteFlag = false;
var that = this;
var params = new URLSearchParams();
var jaccount = sessionStorage.getItem("jaccount");

params.append("jaccount", jaccount);
params.append("refactor_site_name", siteName || ""); 
params.append("refactor_site_url", that.siteUrl); 

// 发送POST请求
axios
    .post("http://localhost:8000/index/refactor_site/", params)
    .then(function (response) {
    console.log(response.data["key"]);
    if (response.data["key"] == 1) {
        that.showMessage("网站修改成功！");
        location.reload();
    }
    if (response.data["key"] == 0) {
        that.showMessage("没有检测到您的输入！");
    }
})
    .catch(function (error) {
    // 报错处理
    console.log(error);
});
```

## 后端结构设计

### 爬虫获取数据

在本次项目中需要获取网络公开的资源数据：教务处通知公告、交大新闻、知乎热搜、微博热搜、B站热搜、食堂数据、图书馆数据等。首先需要通过开发者工具调取相关数据接口以发送请求，并针对html、json、xml不同格式进行内容提取。在实际提取时需针对数据格式动态选择 `lxml`，`beautifulSoup` 进行标签提取，使用正则表达式定位相应所需内容。

### 多线程池运行设计

考虑后端采用python语言编写可能导致运行速度较慢，同时顺序访问各资源会造成大量的时间浪费，故考虑设计python3.5版本后出现的异步功能实现多线程池工作。

对于一般计算型的操作，利用协程来回切换执行，来回切换并保存状态反倒会降低性能。但是IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程，即不等待任务结束就可以去执行其他代码。

`async` & `await` 关键字在Python3.5版本中正式引入，基于此编写的协程相比较 `greenlet` 模块和 `yield` 生成器可以让代码可以更加简便。而在Python3.8之后 `@asyncio.coroutine` 装饰器就会被移除，可以进一步简化协程的编写逻辑。

实际的运行过程是：将协程当做任务添加到事件循环的任务列表，然后事件循环检测列表中的协程是否已准备就绪默认可理解为就绪状态，如果准备就绪则执行其内部代码。

而 `await` 是一个只能在协程函数中使用的关键字，用于遇到IO操作时挂起当前协程（任务），当前协程（任务）挂起过程中事件循环可以去执行其他的协程（任务），当前协程IO处理完成时，可以再次切换回来执行await之后的代码。

通过协程同时进行多项任务的处理能够极大地提升后端运行的效率。

### ORM数据库模型

#### 数据库设计

针对项目中的开发需求，设计数据库结构E-R图如下：

![](./img/model.png)

本项目使用到了五个数据表：`User`, `Site`, `Wallpaper`, `SimpleMode` 和 `Task`。其中`Site`, `Wallpaper`, `SimpleMode` 和 `Task`中的 `Jaccount` 与 `User` 中的 `Jaccount` 构成主外键关系。

考虑本项目为小型工程项目，为提升运行效率采用轻便的SQLite作为后台数据库管理。

#### 数据库操作

为避免直接编写SQL语句导致可能的SQL注入问题（详见“安全需求设计”），采用django中的Model层进行ORM操作，针对前端发起的修改数据库内容的请求，编写相应的数据表内容查找、增加、修改、删除操作。

### Jaccount登录组件

根据数据库设计模块中的ER图可以确定，用户的唯一标识符是数据库需要保存的核心数据。在本项目中，采用OAuth2.0协议，调用Jaccount API进行第三方验证。

Jaccount登录的整体流程如下所示：

![](./img/jaccount.png)

- 进行Jaccount接口申请，获取`client_id` ，`client_secret`；
- 后端服务器构造POST请求，发送给Jaccount认证服务器，包含`client_id` ，`client_secret`，验证URL，重定向URL等信息；
- 页面跳转到Jaccount认证页面，用户输入账号密码；
- 认证服务器返回一个Token给后端服务器，服务器保存Token，并且重定向到主页面；
- 主页面加载函数中，借助Token向资源服务器（与认证服务器可以不是同一个）请求数据，资源服务器返回Jaccount账号、姓名等身份信息，身份信息存入后端数据库，同时再向前端传递。

以上部分关键代码如下：

```python
# oauth.py
# 定义OAuth变量，储存CLIENT_ID，CLIENT_SECRET和关键URL
oauth = OAuth()
oauth.register(
    name='jaccount',
    client_id = JACCOUNT_CLIENT_ID,
    client_secret = JACCOUNT_CLIENT_SECRET,
    access_token_url='https://jaccount.sjtu.edu.cn/oauth2/token',
    authorize_url='https://jaccount.sjtu.edu.cn/oauth2/authorize',
    api_base_url='https://api.sjtu.edu.cn/',
    client_kwargs={
        "scope": "basic",
        "token_endpoint_auth_method": "client_secret_basic",
        "token_placement": "header",
    },
)
jaccount = oauth.jaccount

# view.py
# 执行跳转到登录页面，返回token的逻辑，再跳转回主页面的逻辑
@csrf_exempt
def authorize(request):
    token: dict = jaccount.authorize_access_token(request)
    claims = jwt.decode(token.pop('id_token'),
                        jaccount.client_secret, claims_cls=CodeIDToken)
    claims.validate()
    request.session['token'] = token
    request.session['user'] = claims

    redir_uri = f"http://localhost:5173/" 
    return redirect(redir_uri)

# 通过token向资源服务器请求身份信息
def jac(request):
    token = request.session['token']
    access_token = token['access_token']
    requests.packages.urllib3.disable_warnings()
    result = requests.get(f'https://api.sjtu.edu.cn/v1/me/profile?access_token={access_token}', verify=False)
    return result.json()

```

采用Jaccount登录的其中一个好处在于，Jaccount采取了会话机制，一旦登录成功，资源服务器端会建立一个会话，同时返回一个cookie给后端服务器。只要Jaccount账户不登出，每次发送请求的时候都会附带这个cookie，资源服务器就能够返回原先已创建的会话。因此，本项目登录之后，不会因为刷新等操作丢失用户信息，具有较好的鲁棒性；另外，如果当前系统中登录过Canvas等网站，可以借助Session机制直接完成认证，不需要输入密码，具有便捷性。

值得注意的是，后端服务器获取用户信息之后，还需要通过axios的请求和响应，将用户信息返回给前端，前端才能够显示用户名。

### API调取与数据处理

为便于前端不同组件的调用，后端需针对 `GET` 请求和 `POST` 请求编写对应的后端API，同时考虑前端对于数据内容获取的需求，需要将资讯信息和数据库信息统一整理为JSON格式作为前端请求的响应。

### AI文字生成图片组件

AI文生图组件主要调用了阿里云视觉智能开放平台下的[图像生产](https://help.aliyun.com/document_detail/144977.html)技术，但为了提供更好的用户体验，后端还需进行一系列处理。

后端整个处理流程如下图所示：

![](./img/aidraw.png)

首先，后端从前端获取三个参数：文生图提示词 `prompt` 、 是否需要生成高清图的参数 `need_highres` 、 页面尺寸 `page_size` 。其中前两个参数由用户输入，第三个参数由前端直接获取。由于阿里云文生图功能仅提供几种预设尺寸，因此需要根据实际页面尺寸找出最接近的预设尺寸，最后再使用 `cv2.resize` 方法进行缩放。

接着，对提示词 `prompt` 进行处理。根据AI画图的提示词规则，在用户输入的提示词之后自动添加一系列提高绘图质量的关键词，例如 *wallpaper, masterpiece, 8k, best quality, highres, ultra detailed*，降低产生劣质图片的概率。

然后，调用阿里云图像生产API。但由于阿里云的处理流程较为繁琐，需要多步请求。首先将提示词和页面尺寸传给文生图函数 `img_gen` ，得到任务id；再根据id调用请求结果函数 `get_res` ，轮询任务状态直到获得图片url；再按照用户需求选择是否生成高清图片，如果需要就将刚才的url传给图像超分函数 `super_res` ，得到任务id，后续轮询操作同上。需要注意的是，由于阿里云的图像超分功能仍在测试中，所以耗时较长，约3~5分钟，而生成预设尺寸的原图仅需约10秒。

最后，从url下载图片到本地，进行缩放处理后返回路径。同时，将路径信息存入数据库，并给[前端](#壁纸切换和ai文生图组件)返回响应。

## 安全需求设计

### CSRF攻击防范

在django中采用 `django.middleware.csrf.CsrfViewMiddleware` 中间件防范可能出现的CSRF攻击，同时对业务中运行的必要请求视图添加 `@csrf_exempt` 注释以免除中间件的保护，这部分的防范在前端实现。

在前端，对于业务中的必要请求通过正则表达式拦截器防范CSRF攻击，具体代码如下：

```
axiosInstance.interceptors.request.use((config) => {
  config.headers['X-Requested-With'] = 'XMLHttpRequest'
  const regex = /.*csrftoken=([^;.]*).*$/
  config.headers['X-CSRFToken'] = document.cookie.match(regex) === null ? null : document.cookie.match(regex)[1]
  return config
})
```

### SQL注入防范

在django中不直接使用SQL语句进行数据库的访问，而是使用对象关系映射（Object Relational Mapping）来做数据的增删改查。ORM框架在运行时就能参照映射文件的信息，把对象持久化到数据库中，从而有效地避免了SQL注入攻击。

### 点击劫持防范

现代浏览器尊重 `X-Frame-Options HTTP` 头，它表明是否允许在框架或 `iframe` 中加载资源。如果响应包含值为 `SAMEORIGIN` 的头，那么只有当请求来自同一个网站时，浏览器才会在框架中加载资源。如果头被设置为 `DENY`，那么无论请求是由哪个网站发出的，浏览器都会阻止资源在框架中加载。

在django中，使用一组可用于覆盖中间件或仅为某些视图设置头的视图装饰器。这样，`X-Frame-Options HTTP` 头只有在响应中还没有出现的情况下，才会被中间件或视图装饰者设置。

django中采用 `django.middleware.clickjacking.XFrameOptionsMiddleware` 即可为网站的所有响应设置相同`X-FrameOptions` 值。
